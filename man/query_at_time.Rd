% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ducklake.R
\name{query_at_time}
\alias{query_at_time}
\title{Query Working DuckLake at a point in time}
\usage{
query_at_time(con, query = NULL, timestamp, table = NULL)
}
\arguments{
\item{con}{DuckDB connection from \code{get_working_ducklake()}}

\item{query}{SQL query string. The query can reference the \code{_ingested_at}
column, but this function adds a filter automatically.}

\item{timestamp}{Timestamp for time travel (character "YYYY-MM-DD HH:MM:SS" or POSIXct).
Filters to rows where \code{_ingested_at <= timestamp}.}

\item{table}{Optional table name. If provided and query is NULL, queries all columns.}
}
\value{
Query result as a tibble
}
\description{
Execute a query against the Working DuckLake filtering by ingestion timestamp.
This provides "time travel" capability to see data as it existed at a past time.
}
\details{
This function provides a simple time travel mechanism by filtering on the
\code{_ingested_at} provenance column. For full DuckLake time travel with
transactional consistency, use native DuckLake catalog features.
}
\examples{
\dontrun{
con <- get_working_ducklake(read_only = TRUE)

# query larva table as of january 15th
old_data <- query_at_time(
  con       = con,
  table     = "larva",
  timestamp = "2026-01-15 00:00:00")

# custom query with time filter
results <- query_at_time(
  con       = con,
  query     = "SELECT species_id, COUNT(*) as n FROM larva GROUP BY species_id",
  timestamp = "2026-01-15")
}
}
\concept{ducklake}
